options{  static = true;  DEBUG_PARSER = false;  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)//importimport com.sleepycat.bind.EntryBinding;import com.sleepycat.bind.serial.SerialBinding;import com.sleepycat.bind.serial.StoredClassCatalog;import com.sleepycat.je.Database;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.Cursor;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import com.sleepycat.je.LockMode;import com.sleepycat.je.OperationStatus;import java.io.File;import java.io.Serializable;import java.util.ArrayList;class Table implements Serializable{    private static final long serialVersionUID = 201311408L;	//primary key, foreign key list.	ArrayList<String> pkList;	ArrayList<String> fkList;		//same attribute has same factor. columnList[i], dataTypeList[i], nullableList[i] is one set.	ArrayList<String> columnList;	ArrayList<String> dataTypeList;	ArrayList<String> nullableList;		public Table(ArrayList<String> pkList,	ArrayList<String> fkList,	ArrayList<String> columnList,	ArrayList<String> dataTypeList,	ArrayList<String> nullableList) {		this.pkList = pkList;		this.fkList = fkList;		this.columnList = columnList;		this.dataTypeList = dataTypeList;		this.nullableList = nullableList;	}}class Data implements Serializable {  private static final long serialVersionUID = 230L;  //each row is saved in ArrayList, and rows are saved in ArrayList<Row> (Row = ArrayList<String>)   ArrayList<ArrayList<String>> dataList;    public Data(ArrayList<ArrayList<String >> dataList) {    this.dataList = dataList;  }}//Operand Class.//one is real value, than other value is "". ("", tDC) or (cV, "")class Operand {  String compValue;  String tableDotColumn;  public Operand(String compValue, String tableDotColumn) {    this.compValue = compValue;    this.tableDotColumn = tableDotColumn;  }}//Predicate Class.//Operand 1,2, Operator. if null Operation, operand 2 is null.class Predicate {  Operand operand1;  Operand operand2;  String operator;  //divide null operator, because of comparing operand2 "". (like a.b = "")  String nullOperator;  public Predicate(Operand operand1, Operand operand2, String operator, String nullOperator) {    this.operand1 = operand1;    this.operand2 = operand2;    this.operator = operator;    this.nullOperator = nullOperator;  }}//BooleanValueExpression Class. ( Let's BVE)//BVE is List of BooleanTerm with 'OR'class BooleanValueExpression {  ArrayList<BooleanTerm> booleanTermList;  public BooleanValueExpression(ArrayList<BooleanTerm> booleanTermList) {    this.booleanTermList = booleanTermList;  }}//BooleanTerm Class. (Let's BTerm)//BT is List of BooleanFactor with 'AND'class BooleanTerm {  ArrayList<BooleanFactor> booleanFactorList;  public BooleanTerm(ArrayList<BooleanFactor> booleanFactorList) {    this.booleanFactorList = booleanFactorList;  }}//BooleanFactor Class. (Let's BF)//BF is consist of BooleanTest and the factor whether not factor exists or not.class BooleanFactor {  BooleanTest bTest;  boolean not;  public BooleanFactor(BooleanTest bTest, boolean not) {    this.bTest = bTest;    this.not = not;  }}//BooleanTest Class. (Let's BTest)//BTest is either Predicate or parenthesizedBooleanExpression(=BVE)class BooleanTest {  Predicate pre;  BooleanValueExpression bve;  public BooleanTest(Predicate pre, BooleanValueExpression bve) {    this.pre = pre;    this.bve = bve;  }}//TableExpression Class.//consist of tableNameList, and either BVE or not. (if no, null)class TableExpression {  ArrayList<String> tableNameList;  BooleanValueExpression bve;  public TableExpression(ArrayList<String> tableNameList, BooleanValueExpression bve) {    this.tableNameList = tableNameList;  	this.bve = bve;  }}public class SimpleDBMSParser{  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_SELECT = 4;  public static final int PRINT_INSERT = 5;  public static final int PRINT_DELETE = 6;  public static final int PRINT_SHOW_TABLES = 7;    public static void main(String args[]) throws ParseException  {    //Environment & Database define    Environment tableDbEnv = null;    Environment tableClassEnv = null;    Environment dataDbEnv = null;    Environment dataClassEnv = null;    Database tableDb = null;    Database tableClass = null;    Database dataDb = null;    Database dataClass = null;    /* OPENING DB */		//Open Database Environment or if not, create one.		EnvironmentConfig tableDbEnvConfig = new EnvironmentConfig();		EnvironmentConfig tableClassEnvConfig = new EnvironmentConfig();		EnvironmentConfig dataDbEnvConfig = new EnvironmentConfig();		EnvironmentConfig dataClassEnvConfig = new EnvironmentConfig();		tableDbEnvConfig.setAllowCreate(true);		tableClassEnvConfig.setAllowCreate(true);		dataDbEnvConfig.setAllowCreate(true);		dataClassEnvConfig.setAllowCreate(true);		tableDbEnv = new Environment(new File("db/"), dataDbEnvConfig);		tableClassEnv = new Environment(new File("db/"), dataClassEnvConfig);		dataDbEnv = new Environment(new File("db/"), dataDbEnvConfig);		dataClassEnv = new Environment(new File("db/"), dataClassEnvConfig);		//Open Database or if not, create one.		DatabaseConfig tableDbConfig = new DatabaseConfig();		DatabaseConfig tableClassConfig = new DatabaseConfig();		DatabaseConfig dataDbConfig = new DatabaseConfig();		DatabaseConfig dataClassConfig = new DatabaseConfig();		tableDbConfig.setAllowCreate(true);		tableDbConfig.setSortedDuplicates(true);		dataDbConfig.setAllowCreate(true);		dataDbConfig.setSortedDuplicates(true);		tableClassConfig.setAllowCreate(true);		tableClassConfig.setSortedDuplicates(false);		dataClassConfig.setAllowCreate(true);		dataClassConfig.setSortedDuplicates(false);		tableDb = tableDbEnv.openDatabase(null, "tableDb", tableDbConfig);		tableClass = tableClassEnv.openDatabase(null, "tableClass", tableClassConfig);		dataDb = dataDbEnv.openDatabase(null, "dataDb", dataDbConfig);		dataClass = dataClassEnv.openDatabase(null, "dataClass", dataClassConfig);	      SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    System.out.print("DB_2013-11408> ");	boolean exit = false;    while (!exit)    {      try      {        exit = parser.command(tableDb, tableClass, dataDb, dataClass);      }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);      }    }    if(tableDb != null) tableDb.close();    if(tableClass != null) tableDb.close();    if(dataDb != null) tableDb.close();    if(dataClass != null) tableDb.close();    if(tableDbEnv != null) tableDbEnv.close();    if(tableClassEnv != null) tableClassEnv.close();    if(dataDbEnv != null) tableDbEnv.close();    if(dataClassEnv != null) tableClassEnv.close();    System.exit(0);  }  public static void printMessage(int q)  {        switch(q)    {      case PRINT_SYNTAX_ERROR:      	System.out.println("Syntax error");      	break;      case PRINT_CREATE_TABLE:      	System.out.println("\'CREATE TABLE\' requested");      	break;      case PRINT_DROP_TABLE:      	System.out.println("\'DROP TABLE\' requested");      	break;      case PRINT_DESC:      	System.out.println("\'DESC\' requested");      	break;      case PRINT_SELECT:      	System.out.println("\'SELECT\' requested");      	break;      case PRINT_INSERT:      	System.out.println("\'INSERT\' requested");      	break;      case PRINT_DELETE:      	System.out.println("\'DELETE\' requested");      	break;      case PRINT_SHOW_TABLES:      	System.out.println("\'SHOW TABLES\' requested");      	break;    }    System.out.print("DB_2013-11408> ");      }  public static void createDb(String tableName, ArrayList<String> tableElementList,			Database tableDb, Database tableClass) {		/*		 * table Element kind		 * coloumn Definition : *coldef:(columnName):(dataType):(nullable)		 * pk constraint : *pkConstraint:(PK_1):(PK_2):...:(PK_n)		 * fk constraint : *fkConstraint:(fk_1):(fk_2):...:(fk_n):*ref:(tableName):(pk_1):...(pk_n)		 */				ArrayList<String> colDefList = new ArrayList<String>();		ArrayList<String> pkList = new ArrayList<String>();		ArrayList<String> fkList = new ArrayList<String>();		ArrayList<String> columnList = new ArrayList<String>();		ArrayList<String> dataTypeList = new ArrayList<String>();		ArrayList<String> nullableList = new ArrayList<String>();				//insert input to colDef, pk, fk list		for(String tableElement : tableElementList) {			if(tableElement.charAt(1) == 'c')				colDefList.add(tableElement);			else if(tableElement.charAt(1) == 'p')				pkList.add(tableElement);			else				fkList.add(tableElement);		}				//insert coldef data into column, dataType, nullable list		String[] colDefElement;		for(String colDef : colDefList) {			colDefElement = colDef.split(":");			columnList.add(colDefElement[1]);			dataTypeList.add(colDefElement[2]);			nullableList.add(colDefElement[3]);		}				//DuplicateColumnDefError		if(columnList.size() > 0 && duplicateColumn(columnList)) {			System.out.println("Create table has failed: column definition is duplicated");			return;		}				//DuplicatePrimaryKeyDefError		if(pkList.size() > 1) {			System.out.println("Create table has failed: primary key definition is duplicated");			return;		}				/* NonExistingColumnDefError */		//checking about pk		ArrayList<String> noColumnList = noExist(columnList, pkList);		if(noColumnList.size() > 0) {			System.out.println("Create table has failed: " + noColumnList.get(0) + " does not exists in column definition");			return;		}				//checking about fk		noColumnList = noExist(columnList, fkList);		if(noColumnList.size() > 0) {			System.out.println("Create table has failed: " + noColumnList.get(0) + " does not exists in column definition");			return;		}				//CharLengthError		for(String dataType : dataTypeList) {			//if dataType is char : "char(intVal)"			if(dataType.charAt(0) == 'c') {				int length = dataType.length();				String intVal = dataType.substring(5, length-1);				if(Integer.parseInt(intVal) < 1) {					System.out.println("Char length should be over 0");					return;				}			}		}				//other errors in fk, ref		try {			DatabaseEntry value = new DatabaseEntry();			DatabaseEntry newTableName = new DatabaseEntry(tableName.getBytes("UTF-8"));			//to save and load in Berkley DB for class Table			StoredClassCatalog tableClassCatalog = new StoredClassCatalog(tableClass);			EntryBinding bind = new SerialBinding(tableClassCatalog, Table.class);						//check the Duplication of new Table name with table names in tableDb			//TableExistenceError				if(tableDb.get(null, newTableName, value, LockMode.DEFAULT) == OperationStatus.SUCCESS) {				System.out.println("Create table has failed: table with the same name already exists");				return;			}						else if(fkList.size() > 0) {				ArrayList<String> fkColumnList = new ArrayList<String>();				ArrayList<String> refColumnList = new ArrayList<String>();				String refTable="";								// true : insert in fkColumnList				boolean fkOrRef = true;				// when ref column list, first String is table Name				boolean locRefTable = false;				for(String fk : fkList) {					String[] fkArray = fk.split(":");					for(int i=1;i<fkArray.length; i++) {						if(fkArray[i].equals("*ref")) {							fkOrRef = false;							locRefTable = true;							continue;						}						if(fkOrRef)							fkColumnList.add(fkArray[i]);						else {							if(locRefTable == true) {								refTable = fkArray[i];								locRefTable = false;							}							else								refColumnList.add(fkArray[i]);						}					}				}								DatabaseEntry refTableName = new DatabaseEntry(refTable.getBytes("UTF-8"));								//ReferenceTableExistenceError					if(tableDb.get(null, refTableName, value, LockMode.DEFAULT) != OperationStatus.SUCCESS) {					System.out.println("Create table has failed: foreign key references non existing table");					return;				}								else {					Table refTableDb = (Table) bind.entryToObject(value);					//pk of ref table					ArrayList<String> pkColumnList = new ArrayList<String>();										if(refTableDb.pkList.size() > 0) {						//pk is only one, so factor is 0.						String[] pkArray = refTableDb.pkList.get(0).split(":");						//factor 0 is *pkConstraint						for(int i = 1; i < pkArray.length; i++) 							pkColumnList.add(pkArray[i]);											}										for(String refColumn : refColumnList) {						//ReferenceTypeError						//when no column which must be reffered in ref table						if(!refTableDb.columnList.contains(refColumn)) {							System.out.println("Create table has failed: foreign key references wrong type");							return;						}												//ReferenceNonPrimaryKeyError						//when no column which must be reffered in ref table's pk						//						else if(!pkColumnList.contains(refColumn)) {							System.out.println("Create table has failed: foreign key references non primary key column");							return;						}					}										//ReferenceTypeError					//when fk size is not same with ref key size					if(fkColumnList.size() != refColumnList.size()) {						System.out.println("Create table has failed: foreign key references wrong type");						return;					}					else {						for(int i = 0; i < fkColumnList.size(); i++) {							String fkDataType = dataTypeList.get(columnList.indexOf(fkColumnList.get(i)));							String refDataType = refTableDb.dataTypeList.get(									refTableDb.columnList.indexOf(refColumnList.get(i)));							//ReferenceTypeError							//when type is different							if(!fkDataType.equals(refDataType)) {								System.out.println("Create table has failed: foreign key references wrong type");								return;							}						}					}				}			}					//Error Check Finished.			String[] pkArray = pkList.get(0).split(":");			//if pk, make nullable value "Y" to "N".			for(int i = 1; i<pkArray.length; i++) {				nullableList.set(columnList.indexOf(pkArray[i]), "N");			}						Table table = new Table(pkList, fkList, columnList, dataTypeList, nullableList);			DatabaseEntry newTable = new DatabaseEntry();			bind.objectToEntry(table, newTable);			tableDb.put(null, newTableName, newTable);			//CreateTableSuccess(#tableName)			System.out.println("'" + tableName + "' table is created");		}		catch(Exception e) {			e.printStackTrace();		}	}		public static boolean duplicateColumn(ArrayList<String> columnList) {		for(String column : columnList) {			/*			 * index value of data which start from first is not same with			 * index value of data which start from the final, it means there are			 * same 2 values in list -> return true.			 */			if(columnList.indexOf(column) != columnList.lastIndexOf(column))				return true;		}		return false;	}		/*	 * checking column list with constraint column list	 * return constraint columns which don't exist in column list	 */	public static ArrayList<String> noExist(ArrayList<String> columnList,			ArrayList<String> constraintList){		ArrayList<String> noExistList = new ArrayList<String>();		String[] constraintArray;		for(String constraint : constraintList) {			constraintArray = constraint.split(":");			/*constraint String is			 * pk : *pkConstraint:(PK_1):(PK_2):...:(PK_n)			 * fk : *fkConstraint:(fk_1):(fk_2):...:(fk_n):*ref:(tableName):(pk_1):...(pk_n) 			 */			//when pk			if(constraintArray[0].equals("*pkConstraint")) {				for(String column : constraintArray) {					//except *pkConstraint					if(!column.equals("*pkConstraint")) 						if(!columnList.contains(column) && !noExistList.contains(column))							noExistList.add(column);									}			}						//when fk			else {				for(String column : constraintArray) {					//except *pkConstraint					if(!column.equals("*fkConstraint")) {						//meet *ref, then stop.						if(column.equals("*ref"))							break;						if(!columnList.contains(column) && !noExistList.contains(column))							noExistList.add(column);					}				}			}		}				return noExistList;	}	public static void dropDb(String tableName, Database tableDb, Database tableClass) {		try {			DatabaseEntry tableNameKey = new DatabaseEntry(tableName.getBytes("UTF-8"));			DatabaseEntry tableNameData = new DatabaseEntry();						//NoSuchTable			if(tableDb.get(null, tableNameKey, tableNameData, LockMode.DEFAULT) != OperationStatus.SUCCESS)				System.out.println("No such table");			//DropReferencedTableError(#tableName)			else if(existRefer(tableName, tableDb, tableClass)) {				System.out.println("Drop table has failed: '" + (tableName) + "' is referenced by other table");			}						//Error Finished. let's Drop (the base...)			//DropSuccess(#tableName)			else {				tableDb.delete(null, tableNameKey);				System.out.println("'" + tableName + "' table is dropped");			}		}		catch(Exception e) {					}	}		//return true if db table which name is (tableName) has referred column in other table.	public static boolean existRefer(String tableName, Database tableDb, Database tableClass) {		Cursor tableDbCursor = tableDb.openCursor(null, null);		DatabaseEntry tableNameKey = new DatabaseEntry();		DatabaseEntry tableNameData = new DatabaseEntry();		StoredClassCatalog tableClassCatalog = new StoredClassCatalog(tableClass);		EntryBinding bind = new SerialBinding(tableClassCatalog, Table.class);				tableDbCursor.getFirst(tableNameKey, tableNameData, LockMode.DEFAULT);		Table refTable;		do {			refTable = (Table) bind.entryToObject(tableNameData);			//checking all refering table.			if(refTable.fkList.size() > 0) {				for(String fk : refTable.fkList) {					String refTableName = "";					String[] fkArray = fk.split(":");					//first value is *fkConstraint.					for(int i = 1; i < fkArray.length; i++) {						if(fkArray[i].equals("*ref")) {							//next value is refering table name.							refTableName = fkArray[i+1];							break;						}					}					//if same, true.					if(tableName.equals(refTableName)) {						tableDbCursor.close();						return true;					}				}			}					} while(tableDbCursor.getNext(tableNameKey, tableNameData, LockMode.DEFAULT) == OperationStatus.SUCCESS);				tableDbCursor.close();		return false;	}		public static void descDb(String tableName, Database tableDb, Database tableClass) {		try {			DatabaseEntry tableNameKey = new DatabaseEntry(tableName.getBytes("UTF-8"));			DatabaseEntry tableNameData = new DatabaseEntry();			StoredClassCatalog tableClassCatalog = new StoredClassCatalog(tableClass);			EntryBinding bind = new SerialBinding(tableClassCatalog, Table.class);						if(tableDb.get(null, tableNameKey, tableNameData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {				Table table = (Table) bind.entryToObject(tableNameData);								ArrayList<String> pkNameList = new ArrayList<String>();				ArrayList<String> fkNameList = new ArrayList<String>();								if(table.pkList.size() > 0) {					String pk = table.pkList.get(0);					String[] pkArray = pk.split(":");					for(int i = 1; i < pkArray.length; i++)						pkNameList.add(pkArray[i]);				}				if(table.fkList.size() > 0) {					String fk = table.fkList.get(0);					String[] fkArray = fk.split(":");					for(int i = 1; i < fkArray.length; i++) {						//collect before *ref						if(fkArray[i].equals("*ref"))							break;						pkNameList.add(fkArray[i]);					}				}								//let's print				System.out.println("-------------------------------------------------");				System.out.println("table_name [" + tableName + "]");				System.out.printf("%-25s", "column_name");				System.out.printf("%-15s", "type");				System.out.printf("%-10s", "null");				System.out.printf("%-10s\n", "key");				for(int i = 0; i < table.columnList.size(); i++) {					String column = table.columnList.get(i);					String dataType = table.dataTypeList.get(i);					String nullable = table.nullableList.get(i);					String key = "";					if(pkNameList.contains(column)) {						key += "PRI";						if(fkNameList.contains(column)) {							key += "/FOR";						}					}					else if(fkNameList.contains(column)){						key += "FOR";					}										System.out.printf("%-25s", column);					System.out.printf("%-15s", dataType);					System.out.printf("%-10s", nullable);					System.out.printf("%-10s\n", key);				}				System.out.println("-------------------------------------------------");			}						//NoSuchTable			else 				System.out.println("No such table");		}		catch(Exception e) {					}	}		public static void showDb(Database tableDb) {		Cursor tableDbCursor = tableDb.openCursor(null, null);		DatabaseEntry tableNameKey = new DatabaseEntry();		DatabaseEntry tableNameData = new DatabaseEntry();				try {			//ShowTablesNoTable			if(tableDb.count() == 0)				System.out.println("There is no table");			else {				tableDbCursor.getFirst(tableNameKey, tableNameData, LockMode.DEFAULT);								ArrayList<String> tableNameList = new ArrayList<String>();				String tableName = "";								do {					tableName = new String(tableNameKey.getData(), "UTF-8");					tableNameList.add(tableName);				} 				while(tableDbCursor.getNext(tableNameKey, tableNameData, LockMode.DEFAULT) == OperationStatus.SUCCESS);								System.out.println("----------------");				for(String table : tableNameList) {					System.out.println(table);				}				System.out.println("----------------");			}		}		catch(Exception e) {					}		finally {			tableDbCursor.close();		}	}}PARSER_END(SimpleDBMSParser)SKIP : { " " | "\r" | "\t" | "\n" }TOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE_TABLE : "create table" >| < NOT_NULL : "not null" >| < PRIMARY_KEY : "primary key" >| < FOREIGN_KEY : "foreign key" >| < REFERENCES : "references" >| < DROP_TABLE : "drop table" >| < DESC : "desc" >| < SHOW_TABLES : "show tables" >| < SELECT : "select" >| < AS : "as" >| < FROM : "from" >| < WHERE : "where" >| < AND : "and" >| < OR : "or" >| < NOT : "not" >| < IS : "is" >| < NULL : "null" >| < INSERT : "insert" >| < INTO : "into" >| < VALUES : "values" >| < DELETE : "delete" >}TOKEN :{  < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>| < SIGN : "+" | "-" >| < DIGIT : [ "0"-"9" ] >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < ALL : "*" >| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >| < DATE_VALUE : < NNNN >"-"< NN >"-"< NN > >| < NNNN : < DIGIT >< DIGIT >< DIGIT >< DIGIT > >| < NN : < DIGIT >< DIGIT > >| < PERIOD : "." >| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET >	| < NON_QUOTE_SPECIAL_CHARACTERS > | " " >| < QUOTE : "'" >| < NON_QUOTE_SPECIAL_CHARACTERS : "!" | "@" | "#" | "$" | "%"	| "^" | "&" | "*" | "(" | ")" | "-" | "_" | "+" | "="	| "\\" | "|" | "{" | "}" | "[" | "]" | ":" | ";" | "~"	| "`" | "<" | ">" | "," | < PERIOD > | "?" | "/" > }boolean command(Database tableDb, Database tableClass, Database dataDb, Database dataClass) :{}{  queryList(tableDb, tableClass, dataDb, dataClass)  {    return false;  }| (    < EXIT >    < SEMICOLON >    {      return true;    }  ) }void queryList(Database tableDb, Database tableClass, Database dataDb, Database dataClass) :{  int q;}{  (    q = query(tableDb, tableClass, dataDb, dataClass)    < SEMICOLON >    {      printMessage(q);    }  )+}int query(Database tableDb,Database tableClass, Database dataDb, Database dataClass) :{  int q;}{(      (	createTableQuery(tableDb, tableClass)	{	  q = PRINT_CREATE_TABLE;	}  )|   (        dropTableQuery(tableDb, tableClass)    {      q = PRINT_DROP_TABLE;    }  )|   (    descQuery(tableDb, tableClass)    {      q = PRINT_DESC;    }  )|   (    selectQuery()    {      q = PRINT_SELECT;    }  )|   (    insertQuery()    {      q = PRINT_INSERT;    }  )|   (    deleteQuery()    {      q = PRINT_DELETE;    }  )|   (    showTablesQuery(tableDb)    {      q = PRINT_SHOW_TABLES;    }  ))  (    {      return q;    }  )}//CREATE TABLEvoid createTableQuery(Database tableDb, Database tableClass) :{  String tn;  ArrayList<String> teList; }{  < CREATE_TABLE >  tn = tableName()  teList = tableElementList()  {    createDb(tn, teList, tableDb, tableClass);  }}ArrayList<String> tableElementList() :{  ArrayList<String> teList = new ArrayList<String>();  String te;}{  < LEFT_PAREN >  te = tableElement()  {    teList.add(te);  }  (    < COMMA >    te = tableElement()    {      teList.add(te);    }  )*  < RIGHT_PAREN >  {    return teList;  }}String tableElement() :{  String columnDef;  String tableConsDef;}{  columnDef = columnDefinition()  {    return columnDef;  }| tableConsDef = tableConstraintDefinition()  {    return tableConsDef;  }}//return columnDefinition String like "*colDef:(columnName):(dataType):(nullable)"String columnDefinition() :{  String colDef;  String cn;  String dt;  String nullable = "Y";}{  cn = columnName()  dt = dataType()  (    < NOT_NULL >    {      nullable = "N";    }  )?  {    colDef = "*colDef:" + cn + ":" + dt + ":" + nullable;    return colDef;  }}String tableConstraintDefinition() :{  String pk;  String fk;}{  pk = primaryKeyConstraint()  {    return pk;  }|  fk = referentialConstraint()  {    return fk;  }}//return pk list like "*pkConstraint:(PK1):(PK2):...:(PK_N)"String primaryKeyConstraint() :{  String cnList;}{  < PRIMARY_KEY >  cnList = columnNameList()  {    return "*pkConstraint" + cnList;  }}//return fk list like "*fkConstraint:(fk1):(fk2):...:(fk_n):*ref:(tableName):..."String referentialConstraint() :{  String fkList;  String refList;  String tn;}{  < FOREIGN_KEY >  fkList = columnNameList()  < REFERENCES >  tn = tableName()  refList = columnNameList()  {    return "*fkConstraint" + fkList + ":*ref:" + tn + refList;  }}//return columnNmaeList like ":(cn1):(cn2):...:(cn_n)"String columnNameList() :{  String cnList = "";  String cn;}{  < LEFT_PAREN >  cn = columnName()  {    cnList += ":" + cn;  }  (    < COMMA >    cn = columnName()    {      cnList += ":" + cn;    }  )*  < RIGHT_PAREN >  {    return cnList;  }}String dataType() :{  Token intVal;}{  < INT >  {    return "int";  }| (    < CHAR >    < LEFT_PAREN >    intVal = < INT_VALUE >    < RIGHT_PAREN >    {      return "char(" + intVal.image + ")";    }  )| < DATE >  {    return "date";  }}//return lowerCase nameString tableName() :{  Token legId;}{  legId = < LEGAL_IDENTIFIER >  {    return legId.image.toLowerCase();  }}String columnName() :{  Token legId;}{  legId = < LEGAL_IDENTIFIER >  {    return legId.image.toLowerCase();  }}//DROP TABLEvoid dropTableQuery(Database tableDb, Database tableClass) :{  String tn;}{  < DROP_TABLE >  tn = tableName()  {    dropDb(tn, tableDb, tableClass);  }}//DESCvoid descQuery(Database tableDb, Database tableClass) :{  String tn;}{  < DESC >  tn = tableName()  {    descDb(tn, tableDb, tableClass);  }}//SHOW TABLESvoid showTablesQuery(Database tableDb) :{}{  < SHOW_TABLES >  {    showDb(tableDb);  }}//SELECTvoid selectQuery(Database tableDb, Database tableClass, Database dataDb, Database dataClass) :{  ArrayList<String> columnNameList;  TableExpression tableExpression;}{  < SELECT >  columnNameList = selectList()  tableExpression = tableExpression()  {    selectDb(columnNameList, tableExpression, tableDb, tableClass, dataDb, dataClass);  }}// select column. ex) select * / select a, b, ...ArrayList<String> selectList() :{  ArrayList<String> selectedColumnList = new ArrayList<String>();  String selectedColumn;}{  < ALL >  {    selectedColumnList.add("*");  }|  selectedColumn = selectedColumn()  {    selectedColumnList.add(selectedColumn);  }  (    < COMMA >    selectedColumn = selectedColumn()    {      selectedColumnList.add(selectedColumn);    }  )*  {    return selectedColumnList;  }}//column. name.first, cake_name, ...//return a.b as c - > a.b*cString selectedColumn() :{  String tableName = "";  String columnName;  String asName = "";}{  (    LOOKAHEAD(2)	tableName = tableName()    < PERIOD >    {      tableName = tableName + ".";    }  )?  columnName = columnName()  (    LOOKAHEAD(2)    < AS >    asName = columnName()    {      asName = "*" + asName;    }  )?  {    return tableName + columnName + asName;  }}//from table_name (where ...)TableExpression tableExpression() :{  ArrayList<String> tableList;  BooleanValueExpression bve = null;}{  (	tableList = fromClause()	( bve = whereClause())?  )  {    return new TableExpression(tableList, bve);  }}ArrayList<String> fromClause() :{  ArrayList<String> tableReferenceList;}{  (	<FROM>	tableReferenceList = tableReferenceList()  )  {    return tableReferenceList;  }}//table list. student (, professor, ...)ArrayList<String> tableReferenceList() :{  ArrayList<String> tableReferenceList = new ArrayList<String>();  String tableName;}{  (	tableName = referedTable()	{	  tableReferenceList.add(tableName);	}	(	  <COMMA>	  tableName = referedTable()	  {	    tableReferenceList.add(tableName);	  }	)*  )  {    return tableReferenceList;  }}// when renaming. student as sString referedTable() :{  String tableName;  String referTableName = "";}{  (	tableName = tableName()	(	  <AS>	  referTableName = tableName()	  {	    referTableName = "*" + referTableName;	  }	)?  )  {    return tableName + referTableName;  }}// where ~BooleanValueExpression whereClause() :{  BooleanValueExpression bve;  }{  (	<WHERE>	bve = booleanValueExpression()  )  {    return bve;  }}// boolean Expression of where, with operation 'OR'BooleanValueExpression booleanValueExpression() :{  ArrayList<BooleanTerm> booleanTermList = new ArrayList<BooleanTerm>();  BooleanTerm bTerm;}{  (	bTerm = booleanTerm()	{	  booleanTermList.add(bTerm);	}	(	  <OR> bTerm = booleanTerm()	  {	    booleanTermList.add(bTerm);	  }	)*  )  {    return new BooleanValueExpression(booleanTermList);  }}// boolean expression with operation 'AND'BooleanTerm booleanTerm() :{  ArrayList<BooleanFactor> booleanFactorList = new ArrayList<BooleanFactor>();  BooleanFactor bf;}{  (    bf = booleanFactor()    {      booleanFactorList.add(bf);    }    (      < AND >      bf = booleanFactor()      {        booleanFactorList.add(bf);      }    )*  )  {    return new BooleanTerm(booleanFactorList);  }}// with Not operationBooleanFactor booleanFactor() :{  BooleanTest bTest;  boolean not = false;}{  (	(	  <NOT>	  {	    not = true;	  }	)?	bTest = booleanTest()  )  {    return new BooleanFactor(bTest, not);  }}BooleanTest booleanTest() :{  Predicate pre = null;  BooleanValueExpression bve = null;}{  (	pre = predicate() |	bve = parenthesizedBooleanExpression()  )  {    return new BooleanTest(pre, bve);  }}// if there are more than 1 boolean expression, use paren BooleanValueExpression parenthesizedBooleanExpression() :{  BooleanValueExpression bve;}{  (	<LEFT_PAREN>	bve = booleanValueExpression()	<RIGHT_PAREN>  )  {    return bve;  }}// comparison boolean value or is null boolean valuePredicate predicate() :{  Predicate pre;}{  (    LOOKAHEAD(4)	pre = comparisonPredicate() |	pre = nullPredicate()  )  {    return pre;  }}// like a = bPredicate comparisonPredicate() :{  Operand operand1;  Operand operand2;  String operator;}{  (    	operand1 = compOperand()	operator = compOp()	operand2 = compOperand()  )  {    return new Predicate(operand1, operand2, operator, "");  } }//return Operand class, because of 2 kinds variable, value or columnNameOperand compOperand() :{  String compValue = "";  String tableName;  String columnName;  String tableDotColumn = "";}{  (    compValue = comparableValue() |    (      LOOKAHEAD(2)      tableName = tableName()      < PERIOD >      {        tableDotColumn += tableName + ".";      }    )? columnName = columnName()    {      tableDotColumn += columnName;    }  )  {    return new Operand(compValue, tableDotColumn);  }}String compOp() :{  Token operator;}{  (    operator = " < " |    operator = " > " |    operator = " = " |    operator = " >= " |    operator = " <= " |    operator = " != "  )  {    return operator.image;  }}//return String value with factor, int - i, char - c, date - dString comparableValue() :{  Token compValue;  //CHAR_STRING value is "~~" or '~~', so start and end must be parsed.  String charString;}{  (    compValue = < INT_VALUE >    {      return "i" + compValue.image;    }    |    compValue = < CHAR_STRING >    {      charString = compValue.image;      charString = charString.substring(1, charString.length()-1);      //maybe SQL distinguishes char_string comparableValue's Capital, but just suppose lowercase.      return "c" + charString.toLowerCase();    }    |    compValue = < DATE_VALUE >    {      return "d" + compValue.image;    }  )}Predicate nullPredicate() :{  Operand operand1;  String operator;}{  (    operand1 = nullOperand()    operator = nullOperation()  )  {    return new Predicate(operand1, null, "", operator);  }}Operand nullOperand() :{  String tableName;  String columnName;  String tableDotColumn = "";}{  (    (      LOOKAHEAD(2)      tableName = tableName()      < PERIOD >      {        tableDotColumn += tableName + ".";      }    )? columnName = columnName()    {      tableDotColumn += columnName;    }  )  {    return new Operand("", tableDotColumn);  }}String nullOperation() :{  String nullOper = "";}{  (    < IS >    {      nullOper += "is ";    }    (      < NOT_NULL >      {        nullOper += "not null";      } |      (        < NOT >        {          nullOper += "not ";        }      )?      < NULL >      {        nullOper += "null";      }    )  )  {    return nullOper;  }}//INSERT QUERYvoid insertQuery() :{}{  (    < INSERT >    < INTO >    tableName()    insertColumnsAndSource()  )}void insertColumnsAndSource() :{}{  (    (      columnNameList()    )?    valueList()  )}void valueList() :{}{  (    < VALUES >    < LEFT_PAREN >    value()    (      < COMMA >      value()    )*    < RIGHT_PAREN >  )}void value() :{}{  (    < NULL > |    comparableValue()  )}//DELETE QUERYvoid deleteQuery() :{}{  (    < DELETE >    < FROM >    tableName()    (      whereClause()    )?  )}	